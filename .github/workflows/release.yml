name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write
  pull-requests: write

jobs:
  # Extract version and check if it's a dry run
  prepare:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract.outputs.version }}
      fullTag: ${{ steps.extract.outputs.fullTag }}
      isDryRun: ${{ steps.extract.outputs.isDryRun }}
      releaseTitle: ${{ steps.extract.outputs.releaseTitle }}

    steps:
      - name: Extract version and dry-run flag
        id: extract
        run: |
          TAG=${GITHUB_REF#refs/tags/v}
          echo "Full tag: $TAG"

          # Check if this is a dry run (contains -dry.)
          if [[ "$TAG" =~ -dry\. ]]; then
            IS_DRY_RUN=true
            # Extract base version (remove -dry.X suffix for validation)
            VERSION=$(echo "$TAG" | sed -E 's/-dry\.[0-9]+$//')
            RELEASE_TITLE="Release v$TAG (DRY RUN)"
            echo "This is a DRY RUN release"
          else
            IS_DRY_RUN=false
            VERSION="$TAG"
            RELEASE_TITLE="Release v$TAG"
            echo "This is a PRODUCTION release"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "fullTag=$TAG" >> $GITHUB_OUTPUT
          echo "isDryRun=$IS_DRY_RUN" >> $GITHUB_OUTPUT
          echo "releaseTitle=$RELEASE_TITLE" >> $GITHUB_OUTPUT

          echo "Version (for validation): $VERSION"
          echo "Full Tag (for artifacts): $TAG"
          echo "Is Dry Run: $IS_DRY_RUN"
          echo "Release Title: $RELEASE_TITLE"

  # Version validation check
  validate-version:
    name: Validate Version
    needs: prepare
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check version matches package.json files
        run: |
          TAG_VERSION="${{ needs.prepare.outputs.version }}"
          echo "Validating version: $TAG_VERSION"

          # Check packages/*/package.json versions
          FAILED=false
          for pkg in packages/*/; do
            if [ -f "$pkg/package.json" ]; then
              PKG_VERSION=$(node -p "require('./$pkg/package.json').version")
              if [ "$PKG_VERSION" != "$TAG_VERSION" ]; then
                echo "❌ Package $pkg version ($PKG_VERSION) does not match tag version ($TAG_VERSION)"
                FAILED=true
              else
                echo "✅ Package $pkg version matches: $PKG_VERSION"
              fi
            fi
          done

          if [ "$FAILED" = true ]; then
            echo ""
            echo "Version validation FAILED!"
            echo "Please update package.json versions to match the tag version: $TAG_VERSION"
            exit 1
          fi

          echo ""
          echo "✅ All package versions match tag version: $TAG_VERSION"

  # Build native libraries and packages
  build-native:
    name: Build Native
    needs: [prepare, validate-version]
    uses: ./.github/workflows/build-native.yml
    with:
      version: ${{ needs.prepare.outputs.fullTag }}
      isDryRun: ${{ needs.prepare.outputs.isDryRun == 'true' }}

  # Build example executables
  build-examples:
    name: Build Examples
    needs: [prepare, validate-version, build-native]
    uses: ./.github/workflows/build-examples.yml
    with:
      version: ${{ needs.prepare.outputs.fullTag }}
      isDryRun: ${{ needs.prepare.outputs.isDryRun == 'true' }}

  # Publish to npm
  npm-publish:
    name: NPM Publish
    needs: [prepare, validate-version, build-native]
    uses: ./.github/workflows/npm-latest-release.yml
    secrets:
      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
    with:
      version: ${{ needs.prepare.outputs.fullTag }}
      isDryRun: ${{ needs.prepare.outputs.isDryRun == 'true' }}

  # Create GitHub release with assets
  github-release:
    name: Create GitHub Release
    needs: [prepare, build-native, build-examples, npm-publish]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Organize release assets
        run: |
          set -e
          WORK_DIR=$(pwd)
          mkdir -p "$WORK_DIR/release-assets"

          FULL_TAG="${{ needs.prepare.outputs.fullTag }}"
          echo "Organizing release assets for tag: $FULL_TAG"
          echo "Working directory: $WORK_DIR"

          # Verify artifact directories exist
          test -d "artifacts/native-binaries-$FULL_TAG" || (echo "❌ native-binaries artifact directory not found!" && exit 1)
          test -d "artifacts/example-executables-$FULL_TAG" || (echo "❌ example-executables artifact directory not found!" && exit 1)

          # Copy native binaries (unzip and rezip with versioned names)
          echo "Processing native binaries..."
          cd "artifacts/native-binaries-$FULL_TAG"

          for zip_file in native-*.zip; do
            if [ -f "$zip_file" ]; then
              platform=$(echo "$zip_file" | sed 's/native-//' | sed 's/.zip//')
              echo "  Processing $platform..."
              unzip -q "$zip_file"
              
              # Repackage with versioned name
              dir_name=$(echo "$zip_file" | sed 's/.zip//')
              if [ -d "$dir_name" ]; then
                cd "$dir_name"
                zip -r "$WORK_DIR/release-assets/opentui-native-v${FULL_TAG}-${platform}.zip" .
                cd ..
                
                # Verify the output
                test -f "$WORK_DIR/release-assets/opentui-native-v${FULL_TAG}-${platform}.zip" || (echo "❌ Failed to create native $platform release asset!" && exit 1)
                echo "  ✅ opentui-native-v${FULL_TAG}-${platform}.zip created"
              else
                echo "❌ Directory $dir_name not found after unzip!" && exit 1
              fi
            fi
          done

          cd "$WORK_DIR"

          # Copy example executables (unzip and rezip with versioned names)
          echo "Processing example executables..."
          cd "artifacts/example-executables-$FULL_TAG"

          for zip_file in examples-*.zip; do
            if [ -f "$zip_file" ]; then
              platform=$(echo "$zip_file" | sed 's/examples-//' | sed 's/.zip//')
              echo "  Processing $platform..."
              unzip -q "$zip_file"
              
              # Repackage with versioned name
              dir_name=$(echo "$zip_file" | sed 's/.zip//')
              if [ -d "$dir_name" ]; then
                cd "$dir_name"
                zip -r "$WORK_DIR/release-assets/opentui-examples-v${FULL_TAG}-${platform}.zip" .
                cd ..
                
                # Verify the output
                test -f "$WORK_DIR/release-assets/opentui-examples-v${FULL_TAG}-${platform}.zip" || (echo "❌ Failed to create examples $platform release asset!" && exit 1)
                echo "  ✅ opentui-examples-v${FULL_TAG}-${platform}.zip created"
              else
                echo "❌ Directory $dir_name not found after unzip!" && exit 1
              fi
            fi
          done

          cd "$WORK_DIR"

          # Verify all expected release assets exist
          echo ""
          echo "Verifying all release assets..."
          EXPECTED_ASSETS=10  # 6 native (darwin-x64, darwin-arm64, linux-x64, linux-arm64, windows-x64, windows-arm64) + 4 examples (no linux-arm64, no windows-arm64)
          ACTUAL_ASSETS=$(ls -1 release-assets/*.zip 2>/dev/null | wc -l | tr -d ' ')

          if [ "$ACTUAL_ASSETS" -ne "$EXPECTED_ASSETS" ]; then
            echo "❌ Expected $EXPECTED_ASSETS release assets, found $ACTUAL_ASSETS"
            ls -lah release-assets/ || echo "No release assets found"
            exit 1
          fi

          echo "✅ All $ACTUAL_ASSETS release assets prepared:"
          echo "   - 6 native binaries (all platforms)"
          echo "   - 4 example executables (darwin-x64, darwin-arm64, linux-x64, windows-x64)"
          ls -lah release-assets/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ needs.prepare.outputs.releaseTitle }}
          files: release-assets/*.zip
          generate_release_notes: true
          draft: false
          prerelease: ${{ needs.prepare.outputs.isDryRun == 'true' }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fail_on_unmatched_files: true
