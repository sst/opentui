name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write
  pull-requests: write

jobs:
  # Extract version and check if it's a dry run
  prepare:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract.outputs.version }}
      isDryRun: ${{ steps.extract.outputs.isDryRun }}
      releaseTitle: ${{ steps.extract.outputs.releaseTitle }}

    steps:
      - name: Extract version and dry-run flag
        id: extract
        run: |
          TAG=${GITHUB_REF#refs/tags/v}
          echo "Full tag: $TAG"

          # Check if this is a dry run (contains -dry.)
          if [[ "$TAG" =~ -dry\. ]]; then
            IS_DRY_RUN=true
            # Extract base version (remove -dry.X suffix)
            VERSION=$(echo "$TAG" | sed -E 's/-dry\.[0-9]+$//')
            RELEASE_TITLE="Release v$TAG (DRY RUN)"
            echo "This is a DRY RUN release"
          else
            IS_DRY_RUN=false
            VERSION="$TAG"
            RELEASE_TITLE="Release v$TAG"
            echo "This is a PRODUCTION release"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "isDryRun=$IS_DRY_RUN" >> $GITHUB_OUTPUT
          echo "releaseTitle=$RELEASE_TITLE" >> $GITHUB_OUTPUT

          echo "Version: $VERSION"
          echo "Is Dry Run: $IS_DRY_RUN"
          echo "Release Title: $RELEASE_TITLE"

  # Version validation check
  validate-version:
    name: Validate Version
    needs: prepare
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check version matches package.json files
        run: |
          TAG_VERSION="${{ needs.prepare.outputs.version }}"
          echo "Validating version: $TAG_VERSION"

          # Check packages/*/package.json versions (excluding vue by default)
          FAILED=false
          for pkg in packages/*/; do
            # Skip vue package
            if [[ "$pkg" == "packages/vue/" ]]; then
              echo "Skipping vue package version check"
              continue
            fi
            
            if [ -f "$pkg/package.json" ]; then
              PKG_VERSION=$(node -p "require('./$pkg/package.json').version")
              if [ "$PKG_VERSION" != "$TAG_VERSION" ]; then
                echo "❌ Package $pkg version ($PKG_VERSION) does not match tag version ($TAG_VERSION)"
                FAILED=true
              else
                echo "✅ Package $pkg version matches: $PKG_VERSION"
              fi
            fi
          done

          if [ "$FAILED" = true ]; then
            echo ""
            echo "Version validation FAILED!"
            echo "Please update package.json versions to match the tag version: $TAG_VERSION"
            exit 1
          fi

          echo ""
          echo "✅ All package versions match tag version: $TAG_VERSION"

  # Build native libraries and packages
  build-native:
    name: Build Native
    needs: [prepare, validate-version]
    uses: ./.github/workflows/build-native.yml
    with:
      version: ${{ needs.prepare.outputs.version }}
      isDryRun: ${{ needs.prepare.outputs.isDryRun == 'true' }}

  # Build example executables
  build-examples:
    name: Build Examples
    needs: [prepare, validate-version, build-native]
    uses: ./.github/workflows/build-examples.yml
    with:
      version: ${{ needs.prepare.outputs.version }}
      isDryRun: ${{ needs.prepare.outputs.isDryRun == 'true' }}

  # Publish to npm
  npm-publish:
    name: NPM Publish
    needs: [prepare, validate-version, build-native]
    uses: ./.github/workflows/npm-latest-release.yml
    secrets:
      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
    with:
      version: ${{ needs.prepare.outputs.version }}
      isDryRun: ${{ needs.prepare.outputs.isDryRun == 'true' }}

  # Create GitHub release with assets
  github-release:
    name: Create GitHub Release
    needs: [prepare, build-native, build-examples, npm-publish]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Organize release assets
        run: |
          mkdir -p release-assets

          # Copy native binaries (unzip and rezip with versioned names)
          cd artifacts/native-binaries-${{ needs.prepare.outputs.version }}

          for zip_file in native-*.zip; do
            if [ -f "$zip_file" ]; then
              platform=$(echo "$zip_file" | sed 's/native-//' | sed 's/.zip//')
              unzip -q "$zip_file"
              
              # Repackage with versioned name
              dir_name=$(echo "$zip_file" | sed 's/.zip//')
              if [ -d "$dir_name" ]; then
                cd "$dir_name"
                zip -r "../../release-assets/opentui-native-v${{ needs.prepare.outputs.version }}-${platform}.zip" .
                cd ..
              fi
            fi
          done

          cd ../..

          # Copy example executables (unzip and rezip with versioned names)
          cd artifacts/example-executables-${{ needs.prepare.outputs.version }}

          for zip_file in examples-*.zip; do
            if [ -f "$zip_file" ]; then
              platform=$(echo "$zip_file" | sed 's/examples-//' | sed 's/.zip//')
              unzip -q "$zip_file"
              
              # Repackage with versioned name
              dir_name=$(echo "$zip_file" | sed 's/.zip//')
              if [ -d "$dir_name" ]; then
                cd "$dir_name"
                zip -r "../../release-assets/opentui-examples-v${{ needs.prepare.outputs.version }}-${platform}.zip" .
                cd ..
              fi
            fi
          done

          cd ../..

          echo "Release assets prepared:"
          ls -lah release-assets/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ needs.prepare.outputs.releaseTitle }}
          files: release-assets/*.zip
          generate_release_notes: true
          draft: false
          prerelease: ${{ needs.prepare.outputs.isDryRun == 'true' }}
          token: ${{ secrets.GITHUB_TOKEN }}
