# 3D Module

The 3D module provides WebGPU and Three.js integration for advanced terminal-based 3D rendering, including sprites, animations, physics, and shader effects.

## Overview

OpenTUI's 3D capabilities enable rich visual effects in the terminal through WebGPU rendering and Three.js integration. The module includes sprite management, particle systems, physics simulations, and custom shaders.

## Module Entry Points

The 3D functionality is available through a separate import:

```typescript
// Main 3D exports
import { 
  ThreeCliRenderer,
  WGPURenderer,
  Canvas,
  SpriteUtils
} from '@opentui/core/3d'

// Animation effects
import {
  SpriteAnimator,
  ExplodingSpriteEffect,
  PhysicsExplodingSpriteEffect,
  SpriteParticleGenerator
} from '@opentui/core/3d/animation'

// Physics adapters
import {
  RapierPhysicsAdapter,
  PlanckPhysicsAdapter
} from '@opentui/core/3d/physics'
```

## Core Components

### Canvas

Terminal-based canvas for 3D rendering:

```typescript
import { Canvas } from '@opentui/core/3d'

const canvas = new Canvas(width, height, {
  backend: 'webgpu', // or 'threejs'
  antialias: true,
  alpha: true
})

// Render to terminal buffer
canvas.render(buffer)
```

### WGPURenderer

WebGPU-based renderer for high-performance graphics:

```typescript
import { WGPURenderer } from '@opentui/core/3d'

const renderer = new WGPURenderer({
  width: 80,
  height: 24,
  devicePixelRatio: 2
})

// Initialize WebGPU
await renderer.initialize()

// Render frame
renderer.render(scene, camera)

// Convert to terminal output
const buffer = renderer.toTerminalBuffer()
```

### Three.js Integration

Terminal rendering with Three.js:

```typescript
import { ThreeCliRenderer } from '@opentui/core/3d'
import * as THREE from 'three'

const renderer = new ThreeCliRenderer({
  width: 80,
  height: 24,
  colors: 256,
  dithering: true
})

// Create Three.js scene
const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000)

// Add objects
const geometry = new THREE.BoxGeometry()
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 })
const cube = new THREE.Mesh(geometry, material)
scene.add(cube)

// Render to terminal
renderer.render(scene, camera)
```

## Sprite System

### Sprite Management

```typescript
import { SpriteResourceManager } from '@opentui/core/3d'

const manager = new SpriteResourceManager()

// Load sprite sheet
await manager.loadSpriteSheet('sprites.png', {
  frameWidth: 32,
  frameHeight: 32,
  animations: {
    idle: { frames: [0, 1, 2, 3], duration: 100 },
    walk: { frames: [4, 5, 6, 7], duration: 80 }
  }
})

// Get sprite instance
const sprite = manager.createSprite('player', 'idle')
```

### Sprite Animation

```typescript
import { SpriteAnimator } from '@opentui/core/3d/animation'

const animator = new SpriteAnimator(sprite)

// Play animation
animator.play('walk', {
  loop: true,
  speed: 1.5,
  onComplete: () => console.log('Animation finished')
})

// Update animation
animator.update(deltaTime)
```

### Sprite Utils

```typescript
import { SpriteUtils } from '@opentui/core/3d'

// Convert image to ASCII art
const ascii = SpriteUtils.imageToAscii(imageData, {
  width: 40,
  height: 20,
  characters: ' .:-=+*#%@'
})

// Generate sprite from text
const textSprite = SpriteUtils.textToSprite('HELLO', {
  font: 'monospace',
  size: 24,
  color: '#00ff00'
})
```

## Animation Effects

### Exploding Sprite Effect

Create explosion animations:

```typescript
import { ExplodingSpriteEffect } from '@opentui/core/3d/animation'

const explosion = new ExplodingSpriteEffect({
  particleCount: 100,
  spread: 45,
  velocity: { min: 2, max: 10 },
  lifetime: 1000,
  gravity: 0.5,
  colors: ['#ff0000', '#ff8800', '#ffff00']
})

// Trigger explosion at position
explosion.explode(x, y)

// Update particles
explosion.update(deltaTime)

// Render to buffer
explosion.render(buffer)
```

### Physics-Based Explosions

Realistic physics explosions:

```typescript
import { PhysicsExplodingSpriteEffect } from '@opentui/core/3d/animation'
import { RapierPhysicsAdapter } from '@opentui/core/3d/physics'

const physics = new RapierPhysicsAdapter()
await physics.initialize()

const explosion = new PhysicsExplodingSpriteEffect({
  physics,
  particleCount: 50,
  explosionForce: 100,
  damping: 0.98,
  restitution: 0.8
})

explosion.explode(x, y, sprite)
```

### Particle Generator

Continuous particle effects:

```typescript
import { SpriteParticleGenerator } from '@opentui/core/3d/animation'

const generator = new SpriteParticleGenerator({
  emissionRate: 10, // particles per second
  lifetime: { min: 1000, max: 2000 },
  velocity: { 
    angle: { min: -45, max: 45 },
    speed: { min: 1, max: 5 }
  },
  size: { start: 1, end: 0.1 },
  opacity: { start: 1, end: 0 },
  colors: {
    start: '#ffffff',
    end: '#000000'
  }
})

// Start emitting
generator.start()

// Update and render
generator.update(deltaTime)
generator.render(buffer)
```

## Physics Integration

### Physics Interface

Common interface for physics engines:

```typescript
interface PhysicsAdapter {
  initialize(): Promise<void>
  createWorld(gravity?: { x: number, y: number }): PhysicsWorld
  createBody(world: PhysicsWorld, options: BodyOptions): PhysicsBody
  step(world: PhysicsWorld, deltaTime: number): void
  dispose(): void
}
```

### Rapier Physics

2D/3D physics with Rapier:

```typescript
import { RapierPhysicsAdapter } from '@opentui/core/3d/physics'

const physics = new RapierPhysicsAdapter()
await physics.initialize()

const world = physics.createWorld({ x: 0, y: 9.8 })

// Create rigid body
const body = physics.createBody(world, {
  type: 'dynamic',
  position: { x: 0, y: 10 },
  shape: 'box',
  size: { width: 2, height: 2 },
  mass: 1,
  restitution: 0.5
})

// Simulate
physics.step(world, 0.016) // 60 FPS
```

### Planck Physics

2D physics with Planck.js:

```typescript
import { PlanckPhysicsAdapter } from '@opentui/core/3d/physics'

const physics = new PlanckPhysicsAdapter()
const world = physics.createWorld({ x: 0, y: -10 })

// Create ground
const ground = physics.createBody(world, {
  type: 'static',
  position: { x: 0, y: 0 },
  shape: 'box',
  size: { width: 100, height: 1 }
})

// Create dynamic box
const box = physics.createBody(world, {
  type: 'dynamic',
  position: { x: 0, y: 20 },
  shape: 'box',
  size: { width: 2, height: 2 },
  density: 1,
  friction: 0.3
})
```

## Shader Support

### Custom Shaders

WebGPU shader integration:

```typescript
const shader = `
  @vertex
  fn vs_main(@location(0) position: vec2<f32>) -> @builtin(position) vec4<f32> {
    return vec4<f32>(position, 0.0, 1.0);
  }
  
  @fragment
  fn fs_main() -> @location(0) vec4<f32> {
    return vec4<f32>(1.0, 0.0, 0.0, 1.0);
  }
`

renderer.addShader('custom', shader)
renderer.useShader('custom')
```

### Post-Processing Effects

Apply shader-based effects:

```typescript
// Bloom effect
renderer.addPostProcess('bloom', {
  threshold: 0.8,
  intensity: 1.5,
  radius: 4
})

// Chromatic aberration
renderer.addPostProcess('chromaticAberration', {
  offset: 0.01
})
```

## Texture Management

### Texture Utils

```typescript
import { TextureUtils } from '@opentui/core/3d'

// Load texture
const texture = await TextureUtils.loadTexture('texture.png')

// Convert to terminal colors
const terminalTexture = TextureUtils.toTerminalColors(texture, {
  palette: 'ansi256',
  dithering: 'floyd-steinberg'
})

// Apply to sprite
sprite.setTexture(terminalTexture)
```

## Performance Optimization

### Level of Detail (LOD)

```typescript
// Automatic LOD based on distance
const lodSprite = new LODSprite([
  { distance: 0, sprite: highDetailSprite },
  { distance: 50, sprite: mediumDetailSprite },
  { distance: 100, sprite: lowDetailSprite }
])

// Update based on camera distance
lodSprite.update(camera)
```

### Instancing

Efficient rendering of many objects:

```typescript
const instances = new InstancedSprites(baseSprite, 1000)

// Update instance transforms
for (let i = 0; i < 1000; i++) {
  instances.setTransform(i, {
    position: { x: Math.random() * 100, y: Math.random() * 100 },
    rotation: Math.random() * Math.PI * 2,
    scale: Math.random() * 2
  })
}

instances.render(buffer)
```

## Integration Example

Complete 3D scene in terminal:

```typescript
import { 
  WGPURenderer, 
  SpriteAnimator,
  RapierPhysicsAdapter,
  PhysicsExplodingSpriteEffect 
} from '@opentui/core/3d'

// Setup
const renderer = new WGPURenderer({ width: 120, height: 40 })
await renderer.initialize()

const physics = new RapierPhysicsAdapter()
await physics.initialize()

const world = physics.createWorld({ x: 0, y: -9.8 })

// Create scene
const sprites = []
for (let i = 0; i < 10; i++) {
  const sprite = createSprite()
  const body = physics.createBody(world, {
    type: 'dynamic',
    position: { x: i * 5, y: 20 }
  })
  sprites.push({ sprite, body })
}

// Animation loop
function animate(deltaTime: number) {
  // Update physics
  physics.step(world, deltaTime)
  
  // Update sprites from physics
  sprites.forEach(({ sprite, body }) => {
    const pos = body.getPosition()
    sprite.position.set(pos.x, pos.y)
    sprite.rotation = body.getRotation()
  })
  
  // Render
  renderer.render(scene, camera)
  const buffer = renderer.toTerminalBuffer()
  terminal.write(buffer)
  
  requestAnimationFrame(animate)
}

animate(0)
```

## API Reference

### Main Exports

- `Canvas` - Terminal canvas for 3D
- `WGPURenderer` - WebGPU renderer
- `ThreeCliRenderer` - Three.js terminal renderer
- `SpriteResourceManager` - Sprite asset management
- `SpriteUtils` - Sprite utilities
- `TextureUtils` - Texture utilities

### Animation Exports

- `SpriteAnimator` - Sprite animation controller
- `ExplodingSpriteEffect` - Explosion effect
- `PhysicsExplodingSpriteEffect` - Physics-based explosion
- `SpriteParticleGenerator` - Particle system

### Physics Exports

- `RapierPhysicsAdapter` - Rapier physics integration
- `PlanckPhysicsAdapter` - Planck.js integration
- `PhysicsAdapter` - Physics interface

## Related Modules

- [Rendering](./rendering.md) - Core rendering system
- [Animation](./animation.md) - Timeline animations
- [Buffer](./buffer.md) - Terminal buffer operations