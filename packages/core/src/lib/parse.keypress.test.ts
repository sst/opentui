import { test, expect } from "bun:test"
import { parseKeypress, nonAlphanumericKeys, type ParsedKey, type KeyEventType } from "./parse.keypress"
import { Buffer } from "node:buffer"

test("parseKeypress - basic letters", () => {
  expect(parseKeypress("a")).toEqual({
    name: "a",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "a",
    raw: "a",
    eventType: "press",
  })

  expect(parseKeypress("A")).toEqual({
    eventType: "press",
    name: "a",
    ctrl: false,
    meta: false,
    shift: true,
    option: false,
    number: false,
    sequence: "A",
    raw: "A",
  })
})

test("parseKeypress - numbers", () => {
  expect(parseKeypress("1")).toEqual({
    eventType: "press",
    name: "1",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: true,
    sequence: "1",
    raw: "1",
  })
})

test("parseKeypress - special keys", () => {
  expect(parseKeypress("\r")).toEqual({
    eventType: "press",
    name: "return",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\r",
    raw: "\r",
  })

  expect(parseKeypress("\n")).toEqual({
    eventType: "press",
    name: "enter",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\n",
    raw: "\n",
  })

  expect(parseKeypress("\x1b\r")).toEqual({
    eventType: "press",
    name: "return",
    ctrl: false,
    meta: true,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b\r",
    raw: "\x1b\r",
  })

  expect(parseKeypress("\x1b\n")).toEqual({
    eventType: "press",
    name: "enter",
    ctrl: false,
    meta: true,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b\n",
    raw: "\x1b\n",
  })

  expect(parseKeypress("\t")).toEqual({
    eventType: "press",
    name: "tab",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\t",
    raw: "\t",
  })

  expect(parseKeypress("\b")).toEqual({
    eventType: "press",
    name: "backspace",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\b",
    raw: "\b",
  })

  expect(parseKeypress("\x1b")).toEqual({
    name: "escape",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b",
    raw: "\x1b",
    eventType: "press",
  })

  expect(parseKeypress(" ")).toEqual({
    eventType: "press",
    name: "space",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: " ",
    raw: " ",
  })
})

test("parseKeypress - ctrl+letter combinations", () => {
  expect(parseKeypress("\x01")).toEqual({
    eventType: "press",
    name: "a",
    ctrl: true,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x01",
    raw: "\x01",
  })

  expect(parseKeypress("\x1a")).toEqual({
    eventType: "press",
    name: "z",
    ctrl: true,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1a",
    raw: "\x1a",
  })
})

test("parseKeypress - meta+character combinations", () => {
  // Simple ESC+character sequences (like ESC+a) set meta=true but option=false
  // These sequences are typically generated by Alt/Option+key on many terminals
  // but the simple ESC prefix doesn't distinguish between Alt/Option and Meta/Cmd
  // so option flag is NOT set (unlike ANSI sequences with explicit modifier bits)
  expect(parseKeypress("\x1ba")).toEqual({
    eventType: "press",
    name: "a",
    ctrl: false,
    meta: true,
    shift: false,
    option: false, // Note: option is NOT set for simple ESC+char sequences
    number: false,
    sequence: "\x1ba",
    raw: "\x1ba",
  })

  expect(parseKeypress("\x1bA")).toEqual({
    eventType: "press",
    name: "A",
    ctrl: false,
    meta: true,
    shift: true,
    option: false, // Note: option is NOT set for simple ESC+char sequences
    number: false,
    sequence: "\x1bA",
    raw: "\x1bA",
  })
})

test("parseKeypress - function keys", () => {
  expect(parseKeypress("\x1bOP")).toEqual({
    eventType: "press",
    name: "f1",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1bOP",
    raw: "\x1bOP",
    code: "OP",
  })

  expect(parseKeypress("\x1b[11~")).toEqual({
    eventType: "press",
    name: "f1",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[11~",
    raw: "\x1b[11~",
    code: "[11~",
  })

  expect(parseKeypress("\x1b[24~")).toEqual({
    eventType: "press",
    name: "f12",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[24~",
    raw: "\x1b[24~",
    code: "[24~",
  })
})

test("parseKeypress - arrow keys", () => {
  expect(parseKeypress("\x1b[A")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[A",
    raw: "\x1b[A",
    code: "[A",
  })

  expect(parseKeypress("\x1b[B")).toEqual({
    eventType: "press",
    name: "down",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[B",
    raw: "\x1b[B",
    code: "[B",
  })

  expect(parseKeypress("\x1b[C")).toEqual({
    eventType: "press",
    name: "right",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[C",
    raw: "\x1b[C",
    code: "[C",
  })

  expect(parseKeypress("\x1b[D")).toEqual({
    eventType: "press",
    name: "left",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[D",
    raw: "\x1b[D",
    code: "[D",
  })
})

test("parseKeypress - navigation keys", () => {
  expect(parseKeypress("\x1b[H")).toEqual({
    eventType: "press",
    name: "home",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[H",
    raw: "\x1b[H",
    code: "[H",
  })

  expect(parseKeypress("\x1b[F")).toEqual({
    eventType: "press",
    name: "end",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[F",
    raw: "\x1b[F",
    code: "[F",
  })

  expect(parseKeypress("\x1b[5~")).toEqual({
    eventType: "press",
    name: "pageup",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[5~",
    raw: "\x1b[5~",
    code: "[5~",
  })

  expect(parseKeypress("\x1b[6~")).toEqual({
    eventType: "press",
    name: "pagedown",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[6~",
    raw: "\x1b[6~",
    code: "[6~",
  })
})

test("parseKeypress - modifier combinations", () => {
  // Shift only: modifier value 2 = bits 1 (0b0001)
  expect(parseKeypress("\x1b[1;2A")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: false,
    meta: false,
    shift: true,
    option: false,
    number: false,
    sequence: "\x1b[1;2A",
    raw: "\x1b[1;2A",
    code: "[A",
  })

  // Alt/Option key: modifier value 3 = bits 2 (0b0010)
  // Note: Alt/Option (same key) sets both meta and option flags
  expect(parseKeypress("\x1b[1;3A")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: false,
    meta: true,
    shift: false,
    option: true,
    number: false,
    sequence: "\x1b[1;3A",
    raw: "\x1b[1;3A",
    code: "[A",
  })

  // Shift+Alt/Option: modifier value 4 = bits 3 (0b0011 = Shift(1) + Alt/Option(2))
  expect(parseKeypress("\x1b[1;4A")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: false,
    meta: true,
    shift: true,
    option: true,
    number: false,
    sequence: "\x1b[1;4A",
    raw: "\x1b[1;4A",
    code: "[A",
  })

  // Ctrl only: modifier value 5 = bits 4 (0b0100)
  expect(parseKeypress("\x1b[1;5A")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: true,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[1;5A",
    raw: "\x1b[1;5A",
    code: "[A",
  })

  // Shift+Alt/Option+Ctrl: modifier value 8 = bits 7 (0b0111 = Shift(1) + Alt/Option(2) + Ctrl(4))
  // Note: meta is true because Alt/Option is pressed, NOT because Meta/Cmd bit is set
  expect(parseKeypress("\x1b[1;8A")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: true,
    meta: true,
    shift: true,
    option: true,
    number: false,
    sequence: "\x1b[1;8A",
    raw: "\x1b[1;8A",
    code: "[A",
  })

  // Meta modifier bit only: modifier value 9 = bits 8 (0b1000)
  // NOTE: This is theoretical - Cmd/Win keys don't reach terminals in practice (OS intercepts them)
  // This tests the ANSI standard's Meta bit (bit 8) which is distinct from Alt bit (bit 2)
  expect(parseKeypress("\x1b[1;9A")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: false,
    meta: true,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[1;9A",
    raw: "\x1b[1;9A",
    code: "[A",
  })

  // Shift+Meta: modifier value 10 = bits 9 (0b1001 = Shift(1) + Meta(8))
  // NOTE: Theoretical - testing ANSI Meta bit which doesn't occur in practice
  expect(parseKeypress("\x1b[1;10A")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: false,
    meta: true,
    shift: true,
    option: false,
    number: false,
    sequence: "\x1b[1;10A",
    raw: "\x1b[1;10A",
    code: "[A",
  })

  // Alt/Option+Meta: modifier value 11 = bits 10 (0b1010 = Alt/Option(2) + Meta(8))
  // NOTE: Theoretical - testing both Alt bit and Meta bit together
  // In practice, only Alt/Option key generates events that reach the terminal
  expect(parseKeypress("\x1b[1;11A")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: false,
    meta: true,
    shift: false,
    option: true,
    number: false,
    sequence: "\x1b[1;11A",
    raw: "\x1b[1;11A",
    code: "[A",
  })

  // All ANSI modifier bits: modifier value 16 = bits 15 (0b1111 = Shift(1) + Alt(2) + Ctrl(4) + Meta(8))
  // NOTE: Partially theoretical - Meta bit doesn't occur in practice, but tests complete ANSI decoding
  expect(parseKeypress("\x1b[1;16A")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: true,
    meta: true,
    shift: true,
    option: true,
    number: false,
    sequence: "\x1b[1;16A",
    raw: "\x1b[1;16A",
    code: "[A",
  })
})

test("parseKeypress - delete key", () => {
  expect(parseKeypress("\x1b[3~")).toEqual({
    eventType: "press",
    name: "delete",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[3~",
    raw: "\x1b[3~",
    code: "[3~",
  })
})

test("parseKeypress - Buffer input", () => {
  const buf = Buffer.from("a")
  expect(parseKeypress(buf)).toEqual({
    eventType: "press",
    name: "a",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "a",
    raw: "a",
  })
})

test("parseKeypress - high byte buffer handling", () => {
  const buf = Buffer.from([160]) // 128 + 32, should become \x1b + " "
  expect(parseKeypress(buf)).toEqual({
    eventType: "press",
    name: "space",
    ctrl: false,
    meta: true,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b ",
    raw: "\x1b ",
  })
})

test("parseKeypress - empty input", () => {
  expect(parseKeypress("")).toEqual({
    eventType: "press",
    name: "",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "",
    raw: "",
  })

  expect(parseKeypress()).toEqual({
    eventType: "press",
    name: "",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "",
    raw: "",
  })
})

test("parseKeypress - special characters", () => {
  expect(parseKeypress("!")).toEqual({
    eventType: "press",
    name: "!",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "!",
    raw: "!",
  })

  expect(parseKeypress("@")).toEqual({
    eventType: "press",
    name: "@",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "@",
    raw: "@",
  })
})

test("parseKeypress - meta space and escape combinations", () => {
  expect(parseKeypress("\x1b ")).toEqual({
    eventType: "press",
    name: "space",
    ctrl: false,
    meta: true,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b ",
    raw: "\x1b ",
  })

  expect(parseKeypress("\x1b\x1b")).toEqual({
    eventType: "press",
    name: "escape",
    ctrl: false,
    meta: true,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b\x1b",
    raw: "\x1b\x1b",
  })
})

test("parseKeypress - rxvt style arrow keys with modifiers", () => {
  expect(parseKeypress("\x1b[a")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: false,
    meta: false,
    shift: true,
    option: false,
    number: false,
    sequence: "\x1b[a",
    raw: "\x1b[a",
    code: "[a",
  })

  expect(parseKeypress("\x1b[2$")).toEqual({
    eventType: "press",
    name: "insert",
    ctrl: false,
    meta: false,
    shift: true,
    option: false,
    number: false,
    sequence: "\x1b[2$",
    raw: "\x1b[2$",
    code: "[2$",
  })
})

test("parseKeypress - ctrl modifier keys", () => {
  expect(parseKeypress("\x1bOa")).toEqual({
    eventType: "press",
    name: "up",
    ctrl: true,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1bOa",
    raw: "\x1bOa",
    code: "Oa",
  })

  expect(parseKeypress("\x1b[2^")).toEqual({
    eventType: "press",
    name: "insert",
    ctrl: true,
    meta: false,
    shift: false,
    option: false,
    number: false,
    sequence: "\x1b[2^",
    raw: "\x1b[2^",
    code: "[2^",
  })
})

test("nonAlphanumericKeys export", () => {
  expect(Array.isArray(nonAlphanumericKeys)).toBe(true)
  expect(nonAlphanumericKeys.length).toBeGreaterThan(0)
  expect(nonAlphanumericKeys).toContain("up")
  expect(nonAlphanumericKeys).toContain("down")
  expect(nonAlphanumericKeys).toContain("f1")
  expect(nonAlphanumericKeys).toContain("backspace")
  expect(nonAlphanumericKeys).toContain("tab")
  expect(nonAlphanumericKeys).toContain("left")
  expect(nonAlphanumericKeys).toContain("right")
})

// Tests for modifier bit calculations and meta/option relationship
// Terminal modifier bits (ANSI standard): Shift=1, Alt/Option=2, Ctrl=4, Meta=8
//
// IMPORTANT REALITY CHECK:
// - Alt and Option are THE SAME PHYSICAL KEY (macOS calls it Option, others call it Alt)
// - Cmd (Mac), Win (Windows), and many Ctrl combos DON'T reach the terminal - OS intercepts them
// - The "Meta" modifier bit (8) exists in ANSI standard but is THEORETICAL
// - In practice, only Alt/Option generates modifier sequences that reach the terminal
//
// The `option` flag: true when ANSI escape sequence has explicit Alt modifier bit (bit 2)
// The `meta` flag: true when ESC prefix is detected OR ANSI Alt/Meta bits are set (legacy naming)
//
// Real terminal behavior on macOS (see key-results file):
// - Alt+letter: sends ESC+char (e.g., "\x1ba") → meta=true, option=false
// - Alt+arrow: sends ANSI sequence (e.g., "\x1b[1;3A") → meta=true, option=true
// - Cmd+anything: NO EVENT reaches terminal (OS intercepts)
// - Ctrl+arrow: NO EVENT reaches terminal on Mac (OS intercepts)
test("parseKeypress - modifier bit calculations and meta/option relationship", () => {
  // Individual modifiers to establish the baseline

  // Shift modifier is bit 0 (value 1), so modifier value 2 = 1 + 1
  const shiftOnly = parseKeypress("\x1b[1;2A")!
  expect(shiftOnly.name).toBe("up")
  expect(shiftOnly.shift).toBe(true)
  expect(shiftOnly.ctrl).toBe(false)
  expect(shiftOnly.meta).toBe(false)
  expect(shiftOnly.option).toBe(false)

  // Alt/Option modifier is bit 1 (value 2), so modifier value 3 = 2 + 1
  // IMPORTANT: Alt/Option (same key, different names) sets BOTH meta and option flags
  const altOnly = parseKeypress("\x1b[1;3A")!
  expect(altOnly.name).toBe("up")
  expect(altOnly.meta).toBe(true) // Alt/Option sets meta flag
  expect(altOnly.option).toBe(true) // Alt/Option sets option flag
  expect(altOnly.ctrl).toBe(false)
  expect(altOnly.shift).toBe(false)

  // Ctrl modifier is bit 2 (value 4), so modifier value 5 = 4 + 1
  const ctrlOnly = parseKeypress("\x1b[1;5A")!
  expect(ctrlOnly.name).toBe("up")
  expect(ctrlOnly.ctrl).toBe(true)
  expect(ctrlOnly.meta).toBe(false)
  expect(ctrlOnly.shift).toBe(false)
  expect(ctrlOnly.option).toBe(false)

  // Meta modifier is bit 3 (value 8), so modifier value 9 = 8 + 1
  // NOTE: This is THEORETICAL - Cmd/Win keys don't reach terminals in practice
  // This tests the ANSI standard's "Meta" bit which is distinct from Alt
  // If a terminal/emulator ever sends this, it means Meta without Alt
  const metaOnly = parseKeypress("\x1b[1;9A")!
  expect(metaOnly.name).toBe("up")
  expect(metaOnly.meta).toBe(true) // Meta bit sets meta flag
  expect(metaOnly.option).toBe(false) // Meta bit does NOT set option flag
  expect(metaOnly.ctrl).toBe(false)
  expect(metaOnly.shift).toBe(false)

  // Combined modifiers to test the relationships

  // Ctrl+Meta = 4 + 8 = 12, so modifier value 13 = 12 + 1
  // NOTE: Theoretical - tests ANSI Meta bit without Alt bit
  const ctrlMeta = parseKeypress("\x1b[1;13A")!
  expect(ctrlMeta.name).toBe("up")
  expect(ctrlMeta.ctrl).toBe(true)
  expect(ctrlMeta.meta).toBe(true)
  expect(ctrlMeta.shift).toBe(false)
  expect(ctrlMeta.option).toBe(false) // No Alt bit, so option is false

  // Shift+Alt/Option = 1 + 2 = 3, so modifier value 4 = 3 + 1
  // Should have meta=true, option=true (Alt/Option key is pressed)
  const shiftAlt = parseKeypress("\x1b[1;4A")!
  expect(shiftAlt.name).toBe("up")
  expect(shiftAlt.shift).toBe(true)
  expect(shiftAlt.option).toBe(true) // Alt/Option sets option
  expect(shiftAlt.meta).toBe(true) // Alt/Option also sets meta
  expect(shiftAlt.ctrl).toBe(false)

  // Alt/Option+Meta/Cmd = 2 + 8 = 10, so modifier value 11 = 10 + 1
  // Both physical keys pressed: Alt/Option key AND Meta/Cmd key
  const altMeta = parseKeypress("\x1b[1;11A")!
  expect(altMeta.name).toBe("up")
  expect(altMeta.meta).toBe(true) // Both Alt/Option and Meta/Cmd set meta flag
  expect(altMeta.option).toBe(true) // Alt/Option sets option flag
  expect(altMeta.ctrl).toBe(false)
  expect(altMeta.shift).toBe(false)

  // Ctrl+Alt/Option = 4 + 2 = 6, so modifier value 7 = 6 + 1
  // Should have meta=true, option=true (Alt/Option key is pressed)
  const ctrlAlt = parseKeypress("\x1b[1;7A")!
  expect(ctrlAlt.name).toBe("up")
  expect(ctrlAlt.ctrl).toBe(true)
  expect(ctrlAlt.meta).toBe(true) // Alt/Option sets meta
  expect(ctrlAlt.option).toBe(true) // Alt/Option sets option
  expect(ctrlAlt.shift).toBe(false)

  // All modifiers: Shift(1) + Alt(2) + Ctrl(4) + Meta(8) = 15, so modifier value 16 = 15 + 1
  const allMods = parseKeypress("\x1b[1;16A")!
  expect(allMods.name).toBe("up")
  expect(allMods.shift).toBe(true)
  expect(allMods.option).toBe(true) // Alt is present
  expect(allMods.ctrl).toBe(true)
  expect(allMods.meta).toBe(true) // Both Alt and Meta are present
})

test("parseKeypress - distinguishing between Alt/Option and theoretical Meta modifier", () => {
  // IMPORTANT REALITY:
  // - Alt and Option are THE SAME PHYSICAL KEY (macOS calls it Option, others call it Alt)
  // - This is the ONLY modifier key that reliably reaches the terminal
  // - Cmd (Mac) and Win (Windows) keys are intercepted by the OS and DON'T reach the terminal
  // - The ANSI "Meta" modifier bit (8) is part of the standard but rarely/never seen in practice
  //
  // Real terminal behavior (see key-results file):
  // - Alt+letter: "\x1ba" → meta=true, option=false (simple ESC prefix)
  // - Alt+arrow: "\x1b[1;3A" → meta=true, option=true (ANSI with Alt bit)
  // - Cmd+anything: NO EVENT (OS intercepts)

  // Alt/Option key with arrow (ANSI sequence with modifier bit 2)
  const altArrow = parseKeypress("\x1b[1;3C")! // Real: Alt/Option+Right
  expect(altArrow.name).toBe("right")
  expect(altArrow.meta).toBe(true)
  expect(altArrow.option).toBe(true)
  expect(altArrow.ctrl).toBe(false)
  expect(altArrow.shift).toBe(false)

  // Theoretical: ANSI Meta bit (bit 8) without Alt bit (bit 2)
  // This sequence is valid per ANSI standard but unlikely to occur in practice
  const metaArrow = parseKeypress("\x1b[1;9C")! // Theoretical: Meta bit only
  expect(metaArrow.name).toBe("right")
  expect(metaArrow.meta).toBe(true)
  expect(metaArrow.option).toBe(false) // No Alt bit, so option is false
  expect(metaArrow.ctrl).toBe(false)
  expect(metaArrow.shift).toBe(false)

  // To detect if Alt/Option was pressed in ANSI sequences: check option=true
  expect(altArrow.option).toBe(true)

  // Theoretical: Both ANSI Alt bit and Meta bit set
  const altMetaArrow = parseKeypress("\x1b[1;11C")! // Theoretical: Alt+Meta bits
  expect(altMetaArrow.meta).toBe(true)
  expect(altMetaArrow.option).toBe(true)
})

test("parseKeypress - modifier combinations with function keys", () => {
  // Ctrl+F1 - may work depending on OS/terminal configuration
  const ctrlF1 = parseKeypress("\x1b[11;5~")!
  expect(ctrlF1.name).toBe("f1")
  expect(ctrlF1.ctrl).toBe(true)
  expect(ctrlF1.meta).toBe(false)
  expect(ctrlF1.option).toBe(false)
  expect(ctrlF1.eventType).toBe("press")

  // Alt/Option+F1 - real key combination that reaches terminal
  const altF1 = parseKeypress("\x1b[11;3~")!
  expect(altF1.name).toBe("f1")
  expect(altF1.meta).toBe(true)
  expect(altF1.option).toBe(true)
  expect(altF1.ctrl).toBe(false)
  expect(altF1.eventType).toBe("press")

  // Theoretical: ANSI Meta bit (bit 8) - rarely/never occurs in practice
  const metaF1 = parseKeypress("\x1b[11;9~")!
  expect(metaF1.name).toBe("f1")
  expect(metaF1.meta).toBe(true)
  expect(metaF1.option).toBe(false)
  expect(metaF1.ctrl).toBe(false)
  expect(metaF1.eventType).toBe("press")

  // Shift+Ctrl+F1 - may work depending on OS/terminal configuration
  const shiftCtrlF1 = parseKeypress("\x1b[11;6~")!
  expect(shiftCtrlF1.name).toBe("f1")
  expect(shiftCtrlF1.shift).toBe(true)
  expect(shiftCtrlF1.ctrl).toBe(true)
  expect(shiftCtrlF1.meta).toBe(false)
  expect(shiftCtrlF1.option).toBe(false)
  expect(shiftCtrlF1.eventType).toBe("press")
})

test("parseKeypress - regular parsing always defaults to press event type", () => {
  // Test various regular key sequences to ensure they all default to "press"
  const keys = [
    "a",
    "A",
    "1",
    "!",
    "\t",
    "\r",
    "\n",
    " ",
    "\x1b",
    "\x01", // Ctrl+A
    "\x1ba", // Alt+A
    "\x1b[A", // Up arrow
    "\x1b[11~", // F1
    "\x1b[1;2A", // Shift+Up
    "\x1b[3~", // Delete
  ]

  for (const keySeq of keys) {
    const result = parseKeypress(keySeq)!
    expect(result.eventType).toBe("press")
  }

  // Test with Buffer input too
  const bufResult = parseKeypress(Buffer.from("x"))
  expect(bufResult?.eventType).toBe("press")
})

test("KeyEventType type validation", () => {
  // Test that KeyEventType only allows valid values
  const validEventTypes: KeyEventType[] = ["press", "repeat", "release"]

  for (const eventType of validEventTypes) {
    // This should compile without errors
    const mockKey: ParsedKey = {
      name: "test",
      ctrl: false,
      meta: false,
      shift: false,
      option: false,
      sequence: "test",
      raw: "test",
      number: false,
      eventType: eventType,
    }
    expect(mockKey.eventType).toBe(eventType)
  }
})

test("parseKeypress - ctrl+option+letter combinations", () => {
  // This is ESC (\x1b) followed by \x15 (which is Ctrl+U)
  const ctrlOptionU = parseKeypress("\u001b\u0015")!

  // The sequence should be parsed as meta+ctrl+u
  expect(ctrlOptionU?.name).toBe("u")
  expect(ctrlOptionU?.ctrl).toBe(true)
  expect(ctrlOptionU?.meta).toBe(true) // ESC prefix indicates meta/alt/option
  expect(ctrlOptionU?.shift).toBe(false)
  expect(ctrlOptionU?.option).toBe(false) // Note: option flag is separate from meta
  expect(ctrlOptionU?.sequence).toBe("\u001b\u0015")
  expect(ctrlOptionU?.raw).toBe("\u001b\u0015")
  expect(ctrlOptionU?.eventType).toBe("press")

  // Test other meta+ctrl combinations
  const metaCtrlA = parseKeypress("\x1b\x01") // ESC + Ctrl+A
  expect(metaCtrlA?.name).toBe("a")
  expect(metaCtrlA?.ctrl).toBe(true)
  expect(metaCtrlA?.meta).toBe(true)
  expect(metaCtrlA?.shift).toBe(false)
  expect(metaCtrlA?.option).toBe(false)

  const metaCtrlZ = parseKeypress("\x1b\x1a") // ESC + Ctrl+Z
  expect(metaCtrlZ?.name).toBe("z")
  expect(metaCtrlZ?.ctrl).toBe(true)
  expect(metaCtrlZ?.meta).toBe(true)
  expect(metaCtrlZ?.shift).toBe(false)
  expect(metaCtrlZ?.option).toBe(false)

  // Test option+shift+u for comparison (this reportedly works)
  // Option+Shift+U generates ESC + U (uppercase)
  const optionShiftU = parseKeypress("\x1bU")!
  expect(optionShiftU?.name).toBe("U")
  expect(optionShiftU?.meta).toBe(true)
  expect(optionShiftU?.shift).toBe(true)
  expect(optionShiftU?.ctrl).toBe(false)
  expect(optionShiftU?.option).toBe(false)

  // Edge case: ensure we don't match beyond \x1a (26, which is Ctrl+Z)
  const invalidCtrlSeq = parseKeypress("\x1b\x1b") // ESC + ESC (not a ctrl char)
  expect(invalidCtrlSeq?.name).toBe("escape")
  expect(invalidCtrlSeq?.meta).toBe(true)
  expect(invalidCtrlSeq?.ctrl).toBe(false)

  // Edge case: test boundary at \x1a
  const metaCtrlAtBoundary = parseKeypress("\x1b\x1a") // ESC + Ctrl+Z
  expect(metaCtrlAtBoundary?.name).toBe("z")
  expect(metaCtrlAtBoundary?.ctrl).toBe(true)
  expect(metaCtrlAtBoundary?.meta).toBe(true)
})

test("parseKeypress - filters out SGR mouse events", () => {
  const mouseDown = parseKeypress("\x1b[<0;10;5M")!
  expect(mouseDown).toBeNull()

  const mouseUp = parseKeypress("\x1b[<0;10;5m")!
  expect(mouseUp).toBeNull()

  const mouseDrag = parseKeypress("\x1b[<32;15;8M")!
  expect(mouseDrag).toBeNull()

  const mouseScroll = parseKeypress("\x1b[<64;20;10M")!
  expect(mouseScroll).toBeNull()
})

test("parseKeypress - filters out basic mouse events", () => {
  const basicMouse = parseKeypress("\x1b[M abc")!
  expect(basicMouse).toBeNull()
})
